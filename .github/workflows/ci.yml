name: ci

on:
  push:
   branches:
     - main
   paths:
     - 'todo/**'
  workflow_dispatch:

jobs:
  version:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      VERSION: ${{ steps.version.outputs.VERSION }}
      VERSION_TAG: ${{ steps.version.outputs.VERSION_TAG }}
      IS_CHANGED: ${{ steps.version.outputs.IS_CHANGED }}
      IS_TAGGED: ${{ steps.version.outputs.IS_TAGGED }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Semver for TODO APP
      uses: paulhatch/semantic-version@v5.2.1
      id: semver_version
      with:
        # The prefix to use to identify tags
        tag_prefix: "v"
        # A string which, if present in a git commit, indicates that a change represents a
        # major (breaking) change, supports regular expressions wrapped with '/'
        major_pattern: "(MAJOR)"
        # A string which indicates the flags used by the `major_pattern` regular expression. Supported flags: idgs
        major_regexp_flags: ""
        # Same as above except indicating a minor change, supports regular expressions wrapped with '/'
        minor_pattern: "(MINOR)"
        # A string which indicates the flags used by the `minor_pattern` regular expression. Supported flags: idgs
        minor_regexp_flags: ""
        # A string to determine the format of the version output - ${major}.${minor}.${patch}-prerelease${increment}
        version_format: "${major}.${minor}.${patch}"
        # Optional path to check for changes. If any changes are detected in the path the
        # 'changed' output will true. Enter multiple paths separated by spaces.
        change_path: "todo"
        # Named version, will be used as suffix for name version tag (only in multirepos where I would have v1.0.0-api)
        # namespace: ""
        # If this is set to true, *every* commit will be treated as a new version.
        bump_each_commit: true
        # If true, the body of commits will also be searched for major/minor patterns to determine the version type.
        search_commit_body: true
        # The output method used to generate list of users, 'csv' or 'json'.
        user_format_type: "csv"
        # Prevents pre-v1.0.0 version from automatically incrementing the major version.
        # If enabled, when the major version is 0, major releases will be treated as minor and minor as patch. Note that the version_type output is unchanged.
        # enable_prerelease_mode: false
    
    - name: Set App Version
      id: version
      run: |
         echo "Version: ${{steps.semver_version.outputs.version}}"
         echo "VersionTag: ${{steps.semver_version.outputs.version_tag}}"
         echo "IsChanged: ${{steps.semver_version.outputs.changed}}"
         echo "IsTagged: ${{steps.semver_version.outputs.is_tagged}}"
         
         echo "VERSION=${{steps.semver_version.outputs.version}}" >> $GITHUB_OUTPUT
         echo "VERSION_TAG=${{steps.semver_version.outputs.version_tag}}" >> $GITHUB_OUTPUT
         echo "IS_CHANGED=${{steps.semver_version.outputs.changed}}" >> $GITHUB_OUTPUT
         echo "IS_TAGGED=${{steps.semver_version.outputs.is_tagged}}" >> $GITHUB_OUTPUT
  
  validation:
    needs: [version]
    runs-on: ubuntu-latest
    env:
      IS_TAGGED: ${{ needs.version.outputs.IS_TAGGED }}
      IS_CHANGED: ${{ needs.version.outputs.IS_CHANGED }}
    outputs:
      IS_CHANGED: ${{ steps.code_changed.outputs.IS_CODE_CHANGED }}
    steps:
      - name: Print Info
        run: |
          echo "needs.version.outputs.IS_TAGGED: ${{ needs.version.outputs.IS_TAGGED }}"
          echo "needs.version.outputs.IS_CHANGED: ${{ needs.version.outputs.IS_CHANGED }}"

      - name: Validate this has been already versioned
        id: code_changed
        run: |
          if [[ "${{env.IS_CHANGED}}" != "true"  ]]; then
            echo "Code base has not changed, there is no need to create a new release."
            echo "IS_CODE_CHANGED=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "IS_CODE_CHANGED=true" >> $GITHUB_OUTPUT
          
          if [[ "${{env.IS_TAGGED}}" != "false" ]]; then
            echo "App is already tagged. Can not overwrite an existing release"
            exit 1
          fi
  
  test_only:
     needs: [version, validation]
     if: ${{contains(needs.version.outputs.IS_CHANGED, true)}}
     runs-on: ubuntu-latest
     steps:
       - name: Test
         run: echo "${{ toJSON(needs) }}"

  build:
    needs: [version, validation]
    if: ${{contains(needs.version.outputs.IS_CHANGED, true)}}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./todo    
    permissions:
      contents: read
    env:
      VERSION: ${{ needs.version.outputs.VERSION }}
      VERSION_TAG: ${{ needs.version.outputs.VERSION_TAG }}
      IS_CHANGED: ${{ needs.version.outputs.IS_CHANGED }}
      IS_TAGGED: ${{ needs.version.outputs.IS_TAGGED }}
    outputs:
      RELEASE_NAME: ${{ steps.create_archive.outputs.RELEASE_NAME }}
    
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'microsoft'
      
      - name: Set the release version
        run: |
          mv ./pom.xml ./pom.xml.bak
          ls -la
          java ../scripts/JavaUtils.java -update_pom_version ./pom.xml.bak ${{env.VERSION}} ./pom.xml
      
      - name: Set the git commit id
        run: |
          mv ./pom.xml ./pom.xml.bak
          ls -la
          java ../scripts/JavaUtils.java -update_git_commit_id ./pom.xml.bak "${GITHUB_SHA}" ./pom.xml
      
      - name: Build the .jar
        run: |
          ./mvnw clean package -DskipTests
      
      - name: Build ZIP including scripts directory
        id: create_archive
        run: |
          ls -la ./target
          if [[ ! -f "./target/todo-${{env.VERSION}}.jar" ]]; then
            echo "File ./target/todo-${{env.VERSION}}.jar does not exists. Check the build script."
            exit 1
          fi
          mkdir ./todo-${{env.VERSION}}
          mv "./target/todo-${{env.VERSION}}.jar" ./todo-${{env.VERSION}}
          cp -R ../scripts ./todo-${{env.VERSION}}
          rm -rf ./todo-${{env.VERSION}}/scripts/templates
          zip -r todo-${{env.VERSION}}.zip ./todo-${{env.VERSION}}
          ls -la
          echo "RELEASE_NAME=todo-${{env.VERSION}}" >> $GITHUB_OUTPUT
          
      - name: 'Upload build artifact'
        uses: actions/upload-artifact@v2
        with:
          name: todo-${{env.VERSION}}
          path: ./todo/todo-${{env.VERSION}}.zip
          if-no-files-found: error
          retention-days: 1
  
  release:
    needs: [version, build]
    runs-on: ubuntu-latest
    if: ${{contains(needs.version.outputs.IS_CHANGED, true)}}
    #permissions: write-all
    permissions:
      contents: write
      packages: write
      actions: write

    env:
      VERSION: ${{ needs.version.outputs.VERSION }}
      VERSION_TAG: ${{ needs.version.outputs.VERSION_TAG }}
      IS_CHANGED: ${{ needs.version.outputs.IS_CHANGED }}
      IS_TAGGED: ${{ needs.version.outputs.IS_TAGGED }}
      RELEASE_NAME: ${{needs.build.outputs.RELEASE_NAME}}
    
    steps:
      - uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v2
        with:
          name: ${{env.RELEASE_NAME}}
      
      - name: Check downloaded files
        run: |
          pwd
          ls -la
      
      - name: Release APP
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GH_TOKEN_RELEASE
        run: |
          ls -la ./todo-${{env.VERSION}}.zip
          gh release create ${{env.VERSION_TAG}} ./todo-${{env.VERSION}}.zip --notes "Auto release ${{env.VERSION_TAG}}"
  
  deploy:
    needs: [version, release]
    uses: ./.github/workflows/cd.yml
    with:
      version: "v1.0.28"
